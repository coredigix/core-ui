extends ../_layout
append head
	title Form validator
block body
	form.container
		h1 Form validator


		h2 Status messages
		pre.select
			code.html
				:text
					<div class="has-error">
						<div class="when-error">Visible when parent has class: has-error</div>
						<div class="when-warn">Visible when parent has class: has-warn</div>
						<div class="when-info">Visible when parent has class: has-info</div>
						<div class="when-done">Visible when parent has class: has-done</div>
					</div>


		h2 Validation attributes
		p.
			Form validation is executed on element "blur" and on before form submit (if [v-submit] is added to form)
			#[br]Each form control must be inside an html element with class "f-cntrl"
		p Add those attributes to your form control

		//- v-type
		h3 [v-type]: Check content type
		p Predefined types separated by commas are:
		ol
			li empty:	Field is empty
			li email:	Check if it's an email using regex
			li tel:		Check if it's a phone number 
			li url:		Check if it's a valid URL
			li password: Check if it's a valid password (6 &lt;= data.length &lt;= 100)
			li number:	Check if i's a number
			li &gt;=0: Check it's a positive number
			li &gt;0: Check it's a strict positive
			li &lt;=0: Check it's a negative number
			li &lt;0: Check it's a strict negative
		b Example:
		pre.select
			code.html
				:text
					<!-- This field should be empty or contains an email -->
					<div class="f-cntrl">
						<input type="text" v-type="empty, email" v-trim>
						<div class="when-error">Invalid email</div>
					</div>

		h3 [v-fixed]: set fixed dicimal
		pre.select
			code.html
				:text
					<-- useful to represent a price -->
					<div class="f-cntrl">
						<input type="text" v-type=">0" v-fixed="2">
						<div class="when-error">Invalid email</div>
					</div>

		//- v-trim
		h3 [v-trim]: Will trim input content before any validation
		h3 [v-max, v-min]: Set max/min value
		pre.select
			code.html
				:text
					<!-- This field should be empty or contains an email -->
					<div class="f-cntrl">
						<input type="text" v-type="number" v-max="999" v-min="6">
						<div class="when-error">Invalid value</div>
						<div class="when-done">Invalid succeed</div>
					</div>

					<!-- This input file must contains between 9 and 17 selected files -->
					<div class="f-cntrl">
						<input type="file" multiple v-min="9" v-max="17">
						<div class="alert danger when-error">Expected 9 to 17 files</div>
						<div class="alert success when-done">Well done</div>
					</div>

		h3 [v-min-bytes, v-max-bytes]
		p Used for input files. Set the min and max total bytes

		//- [v-regex]
		h3 [v-regex]: Use a regex
		pre.select
			code.html
				:text
					<!-- This field should be empty or contains an email -->
					<div class="f-cntrl">
						<input type="text" v-regex="^[a-z].{17}">
						<div class="when-error">Value must starts with [a-z] and contains at least 18 characters.</div>
					</div>
		//- [v-checked]
		h3 [v-checked]: Used for checkboxes and radio buttons (switches are checkboxes or radio buttons too)
		pre.select
			code.html
				:text
					<div class="f-cntrl">
						<label class="block f-checkbox">
							<input type="checkbox" v-checked>
							<span>
								<svg viewBox='0 0 12 10'><polyline points="1.5 6 4.5 9 10.5 1" /></svg>
							</span>
							<span class="label"> I accept the agreement</span>
						<label>
						<div class="when-error">You need to accept the agreement</div>
					</div>
		
		//- Use custom validation
		h3 use custom validation:
		b 1- Create your custom (sync or async) validation function.
		pre.select
			code.coffeescript
				:text
					#- using sync callback
					Core.vCb 'myFieldValidator', (event)->
						return

					#- using async callback or returning promise
					Core.vCb 'myFieldValidator', (event)->
						resp= await Core.getJSON('https://...') # check from the server
						return resp

					###*
					 * Possible returns
					###
						return true		# done
						return {done: true}	# done
						return {done: 'html message'} # done, show this message in the sibling <div class="when-done">

						return false	# has error
						throw Error		# has error
						return {error: true}	# has error
						return {error: 'html message'}	# has error, show this message in the sibling <div class="when-error">

						return {warn: true}	# has warning (validation failed too)
						return {warn: 'html message'}	# has warning, show this message in the sibling <div class="when-warn">

						return {value:'***'} # replace input value with this
		
		b 2- Add it to your fields using attribute: [v-cb]
		pre.select
			code.html
				:text
					<div class="f-cntrl">
						<input type="text" v-cb="myFieldValidator">
						<div class="when-error">Validation failed</div>
						<div class="when-warn">Validation has warns</div>
						<div class="when-done">Validation ok</div>
					</div>

		h2 Do validation before submiting form
		p Just add the attribute "v-submit" to your form
		pre.select
			code.html
				:text
					<form action="..." method="..." enctype="..." v-submit>
						...
					</form>

		h3 Add your custom submit handler
		pre.select
			code.coffeescript
				:text
					Core.vSubmit 'handlerName', (event)->
						event.preventDefault()	# prevent native form submiting
						action= @getAttribute('action')	# get target URL from "action" attribute
						#- Send using ajax or any logic
						return
		pre.select
			code.html
				:text
					<form action="..." v-submit="handlerName">
						...
					</form>

		h3 Predefined actions
		pre.select
			code.html
				:text
					<!-- Send form as url encoded using GET method -->
						<form action="Target-URL" method="GET" enctype="application/x-www-form-urlencoded" v-submit="ajax"> ... </form>
						<!-- or -->
						<form action="Target-URL" v-submit="query"> ... </form>

					<!-- Send form as mutlipart data (send files using POST) -->
						<form action="Target-URL" enctype="multipart/form-data" v-submit="ajax"> ... </form>
						<!-- or -->
						<form action="Target-URL" v-submit="multipart"> ... </form>


					<!-- Send form as url encoded (using POST) -->
						<form action="Target-URL" enctype="application/x-www-form-urlencoded" v-submit="ajax"> ... </form>
						<!-- or -->
						<form action="Target-URL" v-submit="ajax"> ... </form>


					<!-- Send form as JSON data -->
						<form action="Target-URL" v-submit="json"> ... </form>

		h2 Input operation before submit
		pre.select
			code.html
				:text
					<!-- call method "OPERATION_NAME" on this input before submiting -->
					<input type="..." v-submit="OPERATION_NAME arg1 arg2 ...">

					<!--
					Core.vSubmit('OPERATION_NAME', async function(arg1, arg2, ...){});
					-->
		h3 Predefined operations
		pre.select
			code.html
				:text
					<!-- resize an image before upload -->
					<input type="..." v-submit="resize 300"> <!-- resize to 300x -->
					<input type="..." v-submit="resize 300x500"> <!-- resize to 300x500 -->
					<input type="..." v-submit="resize x500"> <!-- resize to 300x500 -->
					<input type="..." v-submit="resize 600x500 cover"> <!-- resize to 300x500 -->
					<input type="..." v-submit="resize 600x500 contain"> <!-- resize to 300x500 -->
					<input type="..." v-submit="resize 600x500 fill"> <!-- resize to 300x500 -->

					<!-- resize an image to maximum value before upload: reduce image size -->
					<input type="..." v-submit="resizeMax 300x"> <!-- resize to 300x300 -->
					<input type="..." v-submit="resizeMax 300x500"> <!-- resize to 300x500 -->


	form.container
		h2 Tests:
			.f-cntrl
				input.f-input(name="name" v-trim)

					
	//- Scripts
	script hljs.initHighlightingOnLoad();